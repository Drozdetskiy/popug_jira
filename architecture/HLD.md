# HLD
## Описание
Учебный проект курса асинхронная архитектура.
Система - PopugJira
Система отвечает за инновационный подход созданию и ассайну рабочих тасок для попугов.
## Service Diagram
![Service Diagram](https://github.com/Drozdetskiy/popug_jira/blob/develop/architecture/services_diagram.png)
## Events Diagram 
![Service Diagram](https://github.com/Drozdetskiy/popug_jira/blob/develop/architecture/eventsourcing_diagram.png)

## Описание сервисов
### PopugJiraWebClient
Веб-клиент проекта PopugJira, через который осуществляется взаимодействие с пользователем.

### UberPopugIncAuth
Единый сервис авторизации, используемый в компании UberPopug
Предполагается, что сервис может генерировать ивенты на создание юзера.
(А так же на изменение и удаление юзера, в случае расширения условий задачи и необходимости в этом).

Сервис авторизации отдает клиенту access_token. 
В access_token указаны:
- Username
- Name
- Surname (да, у нас очень серьезные попугаи)
- Email
- Роль
- Пермишены

Кроме того, предполагается, что есть возможность заиспользовать публичные ключи для расшифровки токена.
Доступен и известен эндпоинт для получения этих ключей во внутренней сети.

### PopugJiraGateway
Сервис, который является точкой входа во внутреннюю структуру проекта.
К каждому запросу клиента должен быть приложен access_token, полученный от UberPopugIncAuth.
Токен расшифровывается публичными ключами сервиса UberPopugIncAuth, полученными от доверенного ресурса.
В случае 

Задачи сервиса: 
- ограничение доступа к внутренним ресурсам и сервисам согласно пермишенам
- проксирование запросов во внутренние сервисы
- создании композиции запросов из разных сервисов.
- кеширование результатов запросов во внутренние сервисы

Взаимодействие со внутренними сервисами происходит синхронно по http
Сервис не имеет своей базы данных и не обслуживает никакую бизнес-логику, кроме создании композиции запросов

### Account
Внутренний сервис, необходимый для хранения полной информации о пользователях, имеющих доступ к системе PopugJira.
Сервис имеет свою базу данных.
Предполагаемая схема базы:
```
table User:
    id: int
    uid: str (unique)
    username: str (unique) - можно подумать об использовании вместо uid
    email: str (unique)
    role: enum (admin, user, manager and etc)
    permissions attay[enum(can_see_analitic, can_reassign_tasks, etc)]
    created_at: datetime
    updated_at: datetime
```

Сервис слушает AccountBus - топик в который попадают ивенты о создании/изменении/удалении юзера.

```
message AccountEvent:
    uid: str
    version: int = 1
    type: enum(create/update/delete)
    user_uid: str
    data: {...данные о юзере}
    created_at: datetime
```

### TaskKeeper:
Сервис отвечающий за создание и изменение тасок. А так же за их реассайн.
Согласно бизнес-условию таски не могут существовать без юзеров. При создании таски юзер выбирается произвольно.
Поэтому, чтобы избежать запросов в сторонние сервисы и для повышения отказоустойчивости было принято решение хранить uid всех нужных для ассайна юзеров (Все роли, кроме менеджера и администратора).
Поэтому сервис слушает топик AccountBus для получение информации о создании таких юзеров или об изменении их роли

Сервис хранит данные о юзерах и тасках:
```
table User:
    id: int
    uid: str (unique)


table Task:
    id: int
    uid: str (unique)
    desctiption: str
    status: enum(open, done) = open
    assignee: FK(User)
    created_at: datetime
    updated_at: datetime
    created_by: FK(User)
    updated_byL FK(User)
```

В момент создания таски, либо изменения ее статуса (перевод задачи в статус Done), создается соответствующий ивент в топике TaskBus.
```
message TaskEvent:
    uid: str
    version: int = 1
    type: enum(create/update)
    task_uid: str
    data: {...данные о таске, предположительно хватит assignee, status}
    created_at: datetime
```

Так же сервис отвечает за реассайн тасок (происходит по нажатию кнопки заассайнить задачи). 
Так как таких ивентов может быть достаточно много (мы не ограничиваем пользователей в количестве нажатий), решено вывести эти ивенты в отдельный топик - ReassignTaskBus.
```
message ReassignTaskEvent:
    uid: str
    version: int = 1
    type: enum(reassign) = reassing
    data: {task_uid_1: new_user_1, task_uid_2: new_user_2, ...}
    created_at: datetime
```

Ивент не обязан содержать информацию о всех переассайненых тасках - при большом количестве данных, их можно разбить на несколько ивентов

### Accounting
Сервис для подсчета баланса.
Задача сервиса - хранить информацию о стоимости ассайна и завершения тасок, о счетах юзеров и ведения аудитлога.
Кроме того, сервис должен осуществлять рассылку о балансе пользователей после завершения отчетного периода (по условию - 1 день)
(Примечание: В том виде, в котором статитика требуется в условии - ее можно подсчитывать в этом сервисе. Если потребуется что-то большее - вероятно стоит выгнести аналитику в отедльный сервис)
Так как рассылку решено осуществлять внутри этого сервиса, сервису необходимо знать имейлы соответствующих юзеров.
Для этого сервис слушает топик AccountBus.
Кроме того, сервис слушает топики TaskBus и ReassignTaskBus.
Это необходимо для генерации стоимости ассайна и завершения тасок и управления балансом пользователей

Данные которые хранятся в сервисе:
```
table User:
    id: int
    uid: str (unique)
    email: str(unique)
    name: str - может понадобиться для формирования текста письма
    surname: str - может понадобиться для формирования текста письма


table Task:
    id: int
    uid: str (unique)


table AuditLog:
    id: int
    user: FK(User)
    action: enum(duty, reassign, new_task, task_completion)
    data: json (например task_uid)
    amount: int = 0
    created_at: datetime

table Balance:
    id: int
    user: FK(User)
    total: int
    sending_status: enum(new, waiting, sended, failed)
    period_start: datetime
    period_end: Optional[datetime]
    created_at: datetime
    updaetd_at: datetime


table TopManagerSalaryMaterializedView:
    start_at: datetime
    finish_at: datetime
    total: int
```

(Можно рассмотреть вопрос о хранении данных в партициях)

Отправка счетов на имейлы пользователей за предыдущий день осуществляется отдельным воркером - celery/отдельный python process

## Технологии
FastApi, Postgres, Redis, RabbitMQ/Kafka

## Минусы и трудности
- Дублирование данных о юзере - мне видется это самым больгим минусом системы
- Возможно будет тяжело изменять систему при изменении бизнес задачи
- Трудность при разрешении конфликтов и рейскондишена ивентов.

## Чего пытался добиться своим решением
- Низкой связанности сервисов
- Решение проблем кеширования на верхнем уровне сервисов, а не в каждом сервисе индивидуально
- Решение проблем авторизации на верхнем уровне сервисов

## Поведение при падении одного из сервисов
Предполагается, что когда Gateway будет пытаться "обогатить данные", если сервис с доп данными не отвечает, то Gateway отправит необогащенный ответ
